---
import { Image } from '@datocms/astro/Image';
import BaseLayout from '~/layouts/BaseLayout.astro';
import AlternateFormatsList from '~/components/AlternateFormatsList';
import DetailList from '~/components/DetailList';
import AuthorsSection from '~/components/AuthorsSection';
import Button from '~/components/ui/Button';
import { executeQuery } from '~/lib/datocms/executeQuery';
import { toPlainText, truncateToLength } from '~/lib/text';
import {
  buildLicenseLabel,
  extractYear,
  formatBookPrice,
  formatCirculation,
  formatEdition,
  formatOrdinal,
  normalizeText,
} from '~/lib/books';
import { getAuthorDisplayName, buildAuthorSegments } from '~/lib/authors';
import { withFallbackSeo } from '~/lib/seo';
import styles from './_style.module.css';
import {
  BOOK_DETAIL_QUERY,
  BOOK_AUTHORS_BOOKS_QUERY,
  BOOK_ALTERNATE_FORMATS_QUERY,
  BOOK_SLUGS_QUERY,
  type BookDetailQueryResult,
  type BookAuthorsBooksResult,
  type BookAlternateFormatsResult,
  type BookSlugsResult,
} from './_graphql';

export const prerender = true;

export async function getStaticPaths() {
  const data = await executeQuery<BookSlugsResult>(BOOK_SLUGS_QUERY);

  return (data.allBooks ?? [])
    .map((book) => book.slug)
    .filter((slug): slug is string => Boolean(slug))
    .map((slug) => ({ params: { slug } }));
}

const { slug } = Astro.params;

if (!slug) {
  throw new Error('Missing book slug');
}

const detailData = await executeQuery<BookDetailQueryResult>(BOOK_DETAIL_QUERY, {
  variables: { slug },
});

const book = detailData.book;

if (!book) {
  throw new Error(`Book not found for slug: ${slug}`);
}

const authors = book.authors ?? [];
const authorIds = authors
  .map((author) => author.id)
  .filter((id): id is string => Boolean(id && id.length > 0));

let authorsBookCounts = new Map<string, number>();

if (authorIds.length > 0) {
  const authorsData = await executeQuery<BookAuthorsBooksResult>(BOOK_AUTHORS_BOOKS_QUERY, {
    variables: { authorIds },
  });

  const counts = new Map<string, number>();
  const targetAuthors = new Set(authorIds);

  for (const relatedBook of authorsData.allBooks ?? []) {
    const seen = new Set<string>();
    for (const author of relatedBook.authors ?? []) {
      const authorId = author.id;
      if (!authorId || seen.has(authorId) || !targetAuthors.has(authorId)) {
        continue;
      }

      counts.set(authorId, (counts.get(authorId) ?? 0) + 1);
      seen.add(authorId);
    }
  }

  authorsBookCounts = counts;
}

const alternateFormatsData = await executeQuery<BookAlternateFormatsResult>(
  BOOK_ALTERNATE_FORMATS_QUERY,
  {
    variables: {
      title: book.title,
      excludeSlug: { neq: book.slug ?? '' },
    } as any,
  },
);

const authorSegments = buildAuthorSegments(authors);
const authorPrefix = book.editedBy ? 'A cura di ' : 'Di ';

const licenseLabel = buildLicenseLabel(book.license);
const formattedPrice = formatBookPrice(book.price);
const formattedEdition = formatEdition(book.edition);
const formattedPrintYear = extractYear(book.printYear);
const descriptionHtml = book.description;
const reviewHtml = book.review && book.review !== book.description ? book.review : null;
const promoText = toPlainText(book.promo);

const formatValue = normalizeText(book.format);
const isArchived = book.archive === true;
const isEbookFormat = formatValue?.toLowerCase() === 'ebook';

const primaryCtaLabel = [
  formattedPrice,
  formatValue ? `Formato ${formatValue}` : null,
  isEbookFormat ? 'Scarica' : 'Ordina',
]
  .filter(Boolean)
  .join(' · ');

const primaryCtaHref = isEbookFormat && book.epubUrl ? book.epubUrl : '/info/ordinare';
const primaryCtaTarget = isEbookFormat && book.epubUrl ? '_blank' : undefined;
const primaryCtaRel = isEbookFormat && book.epubUrl ? 'noopener noreferrer' : undefined;
const showPrimaryCta =
  (isEbookFormat && Boolean(book.epubUrl)) || (!isEbookFormat && (formattedPrice || formatValue));

const alternateFormatsRaw = (alternateFormatsData.allBooks ?? []).filter(
  (alt) => alt.slug !== book.slug,
);

const alternateFormats = alternateFormatsRaw
  .map((alt) => {
    const altFormat = normalizeText(alt.format) ?? 'Altro formato';
    const altIsEbook = altFormat.toLowerCase() === 'ebook';
    const altPrice = formatBookPrice(alt.price);
    const href = altIsEbook && alt.epubUrl ? alt.epubUrl : `/libri/${alt.slug}`;

    return {
      id: alt.id,
      format: altFormat,
      price: altPrice,
      href,
      isExternal: altIsEbook && Boolean(alt.epubUrl),
    };
  })
  .filter((alt) => alt.format.toLowerCase() !== (formatValue?.toLowerCase() ?? ''));

const limitedAlternateFormats = alternateFormats.slice(0, 3);

const authorsCards = authors.map((author) => {
  const name = getAuthorDisplayName(author);
  const biographyPlain = toPlainText(author.biography);
  const biographyExcerpt =
    biographyPlain.length > 0
      ? truncateToLength(biographyPlain, 220)
      : 'Biografia in aggiornamento.';
  const booksCount = authorsBookCounts.get(author.id) ?? (authorIds.includes(author.id) ? 1 : 0);
  const booksLabel =
    booksCount === 1 ? '1 libro con Multimage' : `${booksCount} libri con Multimage`;

  return {
    id: author.id,
    name,
    slug: author.slug ?? null,
    biography: biographyExcerpt,
    booksLabel,
    picture: author.picture,
  };
});

const authorsSectionTitle = authorsCards.length > 1 ? 'Gli autori del libro' : 'L’autore del libro';

const editionDetails = [] as Array<{ label: string; value: string; href?: string }>;

if (book.collection?.name && book.collection.slug) {
  editionDetails.push({
    label: 'Collana',
    value: book.collection.name,
    href: `/collane/${book.collection.slug}`,
  });
}

if (book.isbn) {
  editionDetails.push({ label: 'ISBN', value: book.isbn });
}

if (formattedPrintYear) {
  editionDetails.push({ label: 'Anno di stampa', value: formattedPrintYear });
}

if (book.firstPrintYear) {
  editionDetails.push({ label: 'Prima edizione', value: `${book.firstPrintYear}` });
}

if (book.edition && book.edition > 1 && formattedEdition) {
  editionDetails.push({ label: 'Edizione', value: formattedEdition });
}

for (const reprint of book.reprints ?? []) {
  if (reprint.__typename !== 'ReprintRecord') {
    continue;
  }

  const reprintOrdinal = formatOrdinal(reprint.number);
  if (reprintOrdinal) {
    editionDetails.push({ label: 'Ristampa', value: `${reprintOrdinal} ristampa` });
  }

  const formattedCirculation = formatCirculation(reprint.circulation ?? null);
  if (formattedCirculation) {
    editionDetails.push({ label: 'Tiratura', value: formattedCirculation });
  }

  const reprintYear = extractYear(reprint.year ?? null);
  if (reprintYear) {
    editionDetails.push({ label: 'Anno di ristampa', value: reprintYear });
  }
}

const originalLang = normalizeText(book.originalLang);
if (originalLang) {
  editionDetails.push({ label: 'Lingua originale', value: originalLang });
}

const originalTitle = normalizeText(book.originalTitle);
if (originalTitle) {
  editionDetails.push({ label: 'Titolo originale', value: originalTitle });
}

const translator = normalizeText(book.translator);
if (translator) {
  editionDetails.push({ label: 'Traduttore', value: translator });
}

if (formatValue) {
  editionDetails.push({ label: 'Formato', value: formatValue });
}

if (formattedPrice) {
  editionDetails.push({ label: 'Prezzo di copertina', value: formattedPrice });
}

if (licenseLabel) {
  editionDetails.push({ label: 'Licenza', value: licenseLabel });
}

const graphicsDetails = [] as Array<{ label: string; value: string }>;

if (book.pages) {
  graphicsDetails.push({ label: 'Pagine', value: `${book.pages}` });
}

const illustrator = normalizeText(book.illustrator);
if (illustrator) {
  graphicsDetails.push({ label: 'Illustratore', value: illustrator });
}

const coverDesigner = normalizeText(book.coverDesigner);
if (coverDesigner) {
  graphicsDetails.push({ label: 'Grafica di copertina', value: coverDesigner });
}

const layoutArtist = normalizeText(book.layoutArtist);
if (layoutArtist) {
  graphicsDetails.push({ label: 'Impaginatore', value: layoutArtist });
}

const dimensions = normalizeText(book.dimensions);
if (dimensions) {
  graphicsDetails.push({ label: 'Dimensioni', value: dimensions });
}

const coverResponsiveImage = book.coverImage?.responsiveImage
  ? { ...book.coverImage.responsiveImage, alt: book.coverImage.responsiveImage.alt ?? book.title }
  : null;

const fallbackDescription = toPlainText(book.promo ?? book.description);
const seo = withFallbackSeo(book.seo, {
  title: `${book.title} | Multimage`,
  description: fallbackDescription,
});
---

<BaseLayout seo={seo}>
  <article class="space-y-12">
    <div class={styles.heroGrid}>
      <div class={styles.coverPanel}>
        <div class={styles.coverFrame}>
          {
            coverResponsiveImage ? (
              <Image
                data={coverResponsiveImage}
                sizes="(min-width: 1024px) 320px, 60vw"
                imgClass="h-auto w-full object-contain"
              />
            ) : (
              <div class="flex h-72 items-center justify-center px-6 text-center text-sm font-semibold uppercase tracking-wide text-brand-slate">
                Copertina in arrivo
              </div>
            )
          }
        </div>
      </div>

      <div class={styles.detailCard}>
        <div class="flex flex-col gap-4">
          <div class="space-y-2">
            <p class="text-xs font-semibold uppercase tracking-wider text-brand-slate">
              {book.collection?.name ? `Collana ${book.collection.name}` : 'Catalogo Multimage'}
            </p>
            <h1 class="text-4xl font-serif text-brand-navy md:text-5xl">{book.title}</h1>
            {
              book.subtitle ? (
                <p class="text-lg font-medium text-brand-charcoal/80 md:text-xl">{book.subtitle}</p>
              ) : null
            }
            <p class="text-sm font-semibold uppercase tracking-wide text-brand-charcoal/80">
              <span>{authorPrefix}</span>
              {
                authorSegments.map((segment) =>
                  segment.type === 'text' ? (
                    <span>{segment.value}</span>
                  ) : segment.href ? (
                    <a href={segment.href} class="text-brand-sky hover:text-brand-navy">
                      {segment.label}
                    </a>
                  ) : (
                    <span>{segment.label}</span>
                  ),
                )
              }
            </p>
          </div>

          {promoText ? <p class="text-base italic text-brand-charcoal/80">{promoText}</p> : null}

          {
            descriptionHtml ? (
              <div
                class="space-y-3 text-base leading-relaxed text-brand-charcoal/90 [&_a]:text-brand-sky [&_a:hover]:text-brand-navy [&_strong]:text-brand-charcoal"
                set:html={descriptionHtml}
              />
            ) : null
          }

          <div class="space-y-4 pt-2">
            {
              isArchived ? (
                <div class="space-y-3">
                  <p class="bg-brand-mist/50 p-4 text-sm font-semibold uppercase tracking-wide text-brand-slate">
                    Titolo fuori catalogo.
                  </p>
                  <AlternateFormatsList formats={limitedAlternateFormats} />
                </div>
              ) : (
                <>
                  {formattedPrice || formatValue ? (
                    <p class="text-sm font-semibold uppercase tracking-wide text-brand-charcoal/80">
                      {[formattedPrice, formatValue ? `Formato ${formatValue}` : null]
                        .filter(Boolean)
                        .join(' · ')}
                    </p>
                  ) : null}

                  <div class="flex flex-wrap gap-3">
                    {showPrimaryCta && primaryCtaLabel.length > 0 ? (
                      <Button
                        href={primaryCtaHref}
                        target={primaryCtaTarget ?? undefined}
                        rel={primaryCtaRel ?? undefined}
                      >
                        {primaryCtaLabel}
                      </Button>
                    ) : null}

                    {!isEbookFormat && book.epubUrl ? (
                      <Button
                        href={book.epubUrl}
                        target="_blank"
                        rel="noopener noreferrer"
                        variant="outline"
                      >
                        Scarica eBook
                      </Button>
                    ) : null}
                  </div>

                  <AlternateFormatsList formats={limitedAlternateFormats} />
                </>
              )
            }
          </div>
        </div>
      </div>
    </div>

    {
      reviewHtml ? (
        <section class={styles.reviewSection}>
          <h2 class="text-3xl font-serif text-brand-navy">Quarta di copertina</h2>
          <div
            class="space-y-4 text-base leading-relaxed text-brand-charcoal/90 [&_a]:text-brand-sky [&_a:hover]:text-brand-navy [&_strong]:text-brand-charcoal"
            set:html={reviewHtml}
          />
        </section>
      ) : null
    }

    <AuthorsSection title={authorsSectionTitle} authors={authorsCards} />

    <section class={styles.detailsSection}>
      <div class="bg-brand-mist/60 px-6 py-6 text-center sm:px-12">
        <h2 class="text-3xl font-serif text-brand-navy">Dettagli</h2>
      </div>
      <div class={styles.detailsGrid}>
        <DetailList title="Dettagli edizione" items={editionDetails} />
        <DetailList title="Dettagli grafica" items={graphicsDetails} />
      </div>
    </section>
  </article>
</BaseLayout>
